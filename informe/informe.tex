\documentclass[12pt, a4paper]{article}

% --- Paquetes de Idioma y Codificación ---
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel} 

% --- Paquetes de Formato y Diseño ---
\usepackage{geometry}
\geometry{top=2.5cm, bottom=2.5cm, left=3cm, right=3cm}
\usepackage{parskip} % Espacio entre párrafos en lugar de sangría
\usepackage{setspace}
\onehalfspacing % Interlineado de 1.5

% --- Paquetes Matemáticos  ---
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{amsthm}

% --- Paquetes para Gráficos y Figuras ---
\usepackage{graphicx}
\usepackage{float}
\usepackage{caption}
\usepackage{subcaption}

% --- Paquetes para Código (Solidity/C++) ---
\usepackage{listings}
\usepackage{xcolor}

% Configuración de colores para código
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{style=mystyle}

% Definición del lenguaje Solidity
\lstdefinelanguage{Solidity}{
    keywords={pragma, solidity, contract, function, modifier, event, struct, enum, mapping, address, uint, uint8, uint16, uint32, uint64, uint128, uint256, int, int8, int16, int32, int64, int128, int256, bool, string, bytes, bytes1, bytes2, bytes4, bytes8, bytes16, bytes32, external, public, private, internal, view, pure, payable, returns, return, require, revert, assert, if, else, for, while, do, break, continue, new, delete, this, super, import, library, interface, abstract, is, memory, storage, calldata, emit, constructor, indexed, anonymous, constant, immutable, override, virtual},
    keywordstyle=\color{magenta}\bfseries,
    ndkeywords={euint32, ebool, externalEuint32, externalEbool, FHE, SepoliaConfig},
    ndkeywordstyle=\color{blue}\bfseries,
    sensitive=true,
    comment=[l]{//},
    morecomment=[s]{/*}{*/},
    string=[b]",
    string=[b]',
    morestring=[b]`
}

% --- Hipervínculos ---
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=black,
    filecolor=magenta,      
    urlcolor=blue,
    citecolor=blue,
}

% --- Datos del Documento ---
\title{\textbf{FHElect: Un sistema de votación usando Fully Homomorphic Encryption}}
\author{Fuentes \and Tievoli \and D'Elia \and}

\begin{document}

% --- Portada ---
\maketitle
\thispagestyle{empty} % Sin número de página en la portada
\newpage

% --- Resumen (Opcional) ---
\begin{abstract}
    \emph{
        Los procesos electorales son fundamentales para las democracias y la toma de decisiones en organizaciones privadas. 
        Para garantizar su legitimidad, es esencial asegurar propiedades como el anonimato y la integridad. 
        Este trabajo explora el uso de Fully Homomorphic Encryption (FHE) como solución a los desafíos 
        de los sistemas de votación electrónicos. 
        Se analiza como FHE permite el conteo verificable de votos sobre datos cifrados, 
        preservando la privacidad del votante y asegurando la transparencia.    
        }
\end{abstract}
\newpage

% --- Índice ---
\tableofcontents
\newpage

% --- Inicio del Contenido ---
\setcounter{page}{1}

\section{Introducción y Motivación}

Los sistemas de votación han evolucionado hacia una mayor transparencia y robustez, pero el aumento de escala y requisitos de seguridad ha elevado sus costos e ineficiencias. Actualmente coexisten dos paradigmas principales.

El \textbf{Voto Tradicional} es el estándar en democracias modernas por su confianza histórica y garantía de anonimato físico. No obstante, presenta desventajas significativas: es \textbf{ineficiente temporalmente} (recuento lento), \textbf{costoso} (logística compleja, ej. elecciones nacionales en Argentina 2025: \$230.000 millones \cite{lanacion}) y \textbf{centralizado} (vulnerable a errores y fraude de la autoridad).

El \textbf{Voto Electrónico} surge para agilizar el proceso y reducir costos logísticos. Sin embargo, introduce nuevos desafíos: falta de \textbf{confianza} (el votante no ve su voto físico), riesgos de \textbf{centralización} (manipulación por autoridades corruptas) y vulnerabilidad a \textbf{ataques} informáticos. Las variantes descentralizadas resuelven la centralización pero plantean otros retos. 

\section{Propiedades de un Sistema de Votación}

Para que un sistema sea legítimo, debe garantizar: \textbf{Privacidad} (voto no vinculable al emisor), \textbf{Integridad} (resultado inmutable y exacto), \textbf{Verificabilidad} (tanto Individual como Universal) y \textbf{Resistencia a terceros} (imposibilidad de probar el voto para evitar venta o coerción).

\section{Análisis de los Enfoques Actuales}

Analizando los enfoques existentes bajo estas propiedades:

El \textbf{Voto Tradicional} satisface privacidad y resistencia a terceros (gracias al cuarto oscuro), pero falla en integridad y verificabilidad debido a la dependencia humana y centralizada.

El \textbf{Voto Electrónico Centralizado} mejora la eficiencia pero sacrifica la privacidad (el administrador tiene acceso total), la integridad y la verificabilidad. Además, no suele resistir a terceros (capturas de pantalla).

Una implementación \textbf{Blockchain ``Naive''} (smart contract público) resolvería la integridad y verificabilidad mediante la inmutabilidad de la cadena, pero fallaría catastróficamente en privacidad y resistencia a terceros, ya que los votos serían públicos.

Es necesario un sistema que combine la transparencia de la blockchain con la privacidad del cuarto oscuro.


\section{FHE}

Como se planteó en la sección anterior, realizar las operaciones necesarias con los datos asociados a los votos sin 
revelar su contenido es necesario. La solución a este problema es la criptografía homomórfica.

El cifrado homomórfico permite realizar operaciones sobre datos cifrados sin necesidad de descifrarlos previamente.
El resultado de estas operaciones, cuando se descifra, coincide con el resultado que se obtendría si las operaciones
se hubieran realizado sobre los datos originales.

Si tenemos una función de encriptación $H$ y dos valores $x$ e $y$, un esquema homomórfico aditivo cumple que:
$$
    H(x) + H(y) = H(x + y)
$$

Con esta propiedad es posible sumar los votos sin necesidad de descifrarlos previamente, preservando la privacidad de los votantes.

Existen distintos niveles de homomorfismo. Los esquemas Parcialmente Homomórficos (PHE) 
permiten realizar solo un tipo de operación (sumas o multiplicaciones, pero no ambas).

Fully Homomorphic Encryption (FHE) permite realizar tanto sumas como productos sobre datos cifrados.

\section{Implementación}

Para implementar un sistema de votación que cumpla con todas las propiedades deseadas, utilizamos la tecnología de Zama, específicamente fhEVM. Esta solución permite ejecutar contratos inteligentes sobre datos cifrados en una EVM compatible.

La arquitectura general del sistema consta de los siguientes componentes:
\begin{itemize}
    \item \textbf{Host Chain}: Es la blockchain donde reside el estado y se ejecutan las transacciones. En nuestro caso, usamos la red de prueba Sepolia con soporte para FHE.
    \item \textbf{Coprocesadores}: Realizan el cómputo pesado sobre los datos cifrados fuera de la cadena (off-chain) para evitar costos de gas prohibitivos.
    \item \textbf{Gateway}: Orquesta la comunicación con los coprocesadores y asegura el consenso sobre los resultados cifrados.
    \item \textbf{KMS (Key Management System)}: Gestiona las claves de descifrado de manera distribuida, asegurando que nadie (ni siquiera los operadores de los nodos) pueda ver los datos en claro sin autorización.
\end{itemize}

\subsection{El Smart Contract}

El núcleo de FHElect es un contrato inteligente escrito en Solidity utilizando la librería \texttt{FHE.sol} de Zama. El contrato gestiona el estado de la votación, almacena los votos cifrados y realiza el conteo sin revelar los votos individuales.

\subsubsection{Estructura de Datos}
El contrato mantiene un contador global cifrado (\texttt{euint32}) y un mapeo del voto cifrado de cada votante:

\begin{lstlisting}[]
euint32 private encryptedCount;
mapping(address => ebool) private encryptedVotes;
\end{lstlisting}

\subsubsection{Proceso de Votación}
Cuando un usuario emite un voto, este se cifra en el lado del cliente (client-side) junto con una prueba de conocimiento cero (ZKPoK) para asegurar que el cifrado es válido. El contrato recibe este voto cifrado (\texttt{externalEbool}) y lo procesa:

\begin{lstlisting}[]
function vote(externalEbool externalYesOrNo, bytes calldata proof) external {
    ebool currentVote = FHE.fromExternal(externalYesOrNo, proof);
    // ... logica de actualizacion ...
    addToCount(eboolToOneOrZero(currentVote));
}
\end{lstlisting}

Para sumar el voto al contador total, utilizamos operaciones homomórficas. Dado que el voto es un booleano cifrado (\texttt{ebool}), primero lo convertimos a un entero 0 o 1 usando \texttt{FHE.select}:

\begin{lstlisting}[]
function eboolToOneOrZero(ebool boolValue) private returns (euint32) {
    return FHE.select(boolValue, encryptedConstantOne, encryptedConstantZero);
}
\end{lstlisting}

\subsubsection{Verificabilidad y Privacidad}
Para garantizar la verificabilidad individual, el contrato otorga permisos explícitos al votante para que pueda descifrar su propio voto almacenado, utilizando Listas de Control de Acceso (ACL):

\begin{lstlisting}[]
FHE.allow(currentVote, msg.sender);
\end{lstlisting}

De esta forma, el votante puede consultar \texttt{getMyVote()} y verificar que el sistema guardó correctamente su intención, sin que nadie más pueda acceder a ese dato.

Al finalizar la votación, el dueño del contrato solicita el descifrado del conteo total. Este proceso es asincrónico y requiere la colaboración de la red de KMS para revelar únicamente el resultado final agregados.

\section{Vulnerabilidades y Desafíos}

\subsection{Coerción y Compra de Votos}
Una vulnerabilidad importante en los sistemas de votación electrónica es la coerción. Si un votante puede probar cómo votó (por ejemplo, mostrando su pantalla), un atacante podría comprar su voto.

En FHElect, mitigamos esto permitiendo que los usuarios voten múltiples veces, donde solo el último voto es válido. Si un votante es coaccionado, puede emitir el voto que pide el atacante, recibir su "pago", y luego emitir su voto real, sobrescribiendo el anterior. El contrato maneja esto restando el voto anterior del total antes de sumar el nuevo:

\begin{lstlisting}[]
if (hasVotedBefore) {
    ebool previousVote = encryptedVotes[msg.sender];
    subtractFromCount(eboolToOneOrZero(previousVote));
}
addToCount(eboolToOneOrZero(currentVote));
\end{lstlisting}

\subsection{Análisis de Tráfico}

Aunque el contenido del voto es privado, el hecho de que una dirección emita una transacción es información pública en la blockchain. Esto introduce dos vulnerabilidades principales: \textbf{Identificación del votante}: Si la dirección está vinculada a una identidad del mundo real, se sabe quién votó y cuándo; y \textbf{Detección de voto duplicado}: Un atacante que ha coaccionado a un votante puede monitorear si este envía una segunda transacción para anular el voto coaccionado.

Para mitigar estos riesgos, proponemos dos estrategias complementarias:

\subsubsection{Relayers y Mixnets}
Para romper el vínculo entre la identidad del votante y la transacción de voto, se pueden utilizar intermediarios conocidos como \textbf{Relayers}. En lugar de que el votante envíe la transacción directamente, firma un mensaje fuera de la cadena (off-chain) utilizando estándares como EIP-712. Este mensaje firmado es enviado al relayer, quien lo empaqueta en una transacción y paga el gas necesario para enviarlo a la blockchain.

Sin embargo, si se utiliza un solo relayer centralizado, este podría censurar transacciones o colaborar con un atacante. Para descentralizar esto y ocultar el origen de la comunicación (dirección IP), se podrían usar \textbf{Mixnets} (como Nym o Tor) o \textbf{Ring Signatures} (como en Monero). Estas tecnologías permiten que el mensaje llegue al relayer de manera anónima, dificultando rastrear el origen físico del voto.

\subsubsection{Inyección de Ruido (Dummy Votes)}
Para evitar que un atacante sepa si un usuario está votando realmente o simplemente interactuando con el contrato para confundir, se puede implementar la inyección de tráfico falso o "ruido".

El cliente puede enviar transacciones aleatorias que, desde el punto de vista de un observador externo (incluyendo al atacante), son indistinguibles de un voto real en términos de firma de la función llamada, costo de gas y tamaño de los datos cifrados.
Una idea de implementación es la siguiente: el usuario envía un flag booleano cifrado (\texttt{ebool isDummy}) junto con su voto. El contrato podría utilizar este flag para condicionalmente sumar 0 al conteo total si \texttt{isDummy} es verdadero, o sumar el voto si es falso.
De esta manera, el estado interno del conteo no cambia, pero un observador no puede distinguir entre un voto real y uno dummy, protegiendo así al votante contra el análisis de tráfico temporal. Es importante que se haga una suma con 0 al contador total para que las operaciones no difieran en el gas.

\section{Extensiones}

El diseño de FHElect es extensible a esquemas de votación más complejos.

\subsection{Voto con Múltiples Candidatos}
Para elecciones con más de dos opciones, en lugar de un booleano, el usuario envía el ID del candidato cifrado (\texttt{encryptedCandidateId}). El contrato itera sobre todos los candidatos y suma 1 al contador del candidato cuyo ID coincide con el voto.

\subsection{Voto Rankeado}
Implementamos también un sistema de voto preferencial, donde el votante selecciona $k$ candidatos y se les asignan puntajes decrecientes. El contrato recibe un array de votos cifrados y suma el puntaje correspondiente a cada candidato seleccionado, todo de manera cifrada y verificable.

\section{Conclusiones}

Este trabajo muestra que la tecnología de Fully Homomorphic Encryption (FHE) es una solución viable y potente para resolver el trilema de privacidad, integridad y verificabilidad en los sistemas de votación electrónica. A través de FHElect, logramos un sistema donde:
\begin{enumerate}
    \item La privacidad es absoluta frente a observadores y administradores.
    \item El conteo es íntegro y verificable universalmente.
    \item Cada votante puede auditar su propio voto.
\end{enumerate}

Si bien existen limitaciones en términos de resistencia a la coerción (entre otras vulnerabilidades), las soluciones propuestas y la las mejoras en rendimiento y seguridad de los sistemas de criptografía homomórfica sugieren un futuro prometedor para sistemas de votación descentralizados.

\newpage
\begin{thebibliography}{9}

\bibitem{mit_paper}
\href{https://www.dci.mit.edu/projects/going-from-bad-to-worse-from-internet-voting-to-blockchain-voting }{
    \textit{Going from bad to worse: from internet voting to blockchain voting}. MIT DigitalCurrency Initiative.}

\bibitem{fhevm_whitepaper}
\href{https://github.com/zama-ai/fhevm/blob/main/fhevm-whitepaper.pdf }{Zama AI. \textit{FHEVM Whitepaper}.}

\bibitem{towards_secure_electronic_voting}
\href{https://www.researchgate.net/publication/391686424_Towards_Secure_Electronic_Voting_a_Survey_on_E-Voting_Systems_and_Attacks}{
    \textit{Towards Secure Electronic Voting: a Survey on E-Voting Systems and Attacks}. ResearchGate.}

\bibitem{lanacion}
\href{https://www.lanacion.com.ar/politica/el-costo-de-la-eleccion-sera-de-por-lo-menos-de-230-mil-millones-nid18102025/}{La Nación. \textit{El costo de la elección será de por lo menos de 230 mil millones}. 18/10/2025.}

\end{thebibliography}

\newpage
\appendix

\section{Código de Smart Contracts}

\subsection{FHEVoter.sol}

\begin{lstlisting}[language=Solidity, caption=FHEVoter.sol]
// SPDX-License-Identifier: BSD-3-Clause-Clear
pragma solidity ^0.8.24;

import {FHE, euint32, externalEuint32, ebool, externalEbool} from "@fhevm/solidity/lib/FHE.sol";
import {SepoliaConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

// inherits from SepoliaConfig to enable fhEVM support
contract FHEVoter is SepoliaConfig {
    struct VoterState {
        uint256 lastElectionId;
        ebool encryptedVote;
    }

    euint32 private encryptedCount;
    euint32 private encryptedConstantOne;
    euint32 private encryptedConstantZero;
    mapping(address => VoterState) private voterStates;

    uint32 private clearCount; // =0 by default. It is only used when the owner calls "decryptCount"
    address private owner;
    bool private isVotingOpen;
    uint256 private electionId;

    event CountDecrypted(uint32 count);
    event VotingStarted();
    event VotingClosed();

    constructor() {
        owner = msg.sender;
        encryptedConstantOne = FHE.asEuint32(1);
        encryptedConstantZero = FHE.asEuint32(0);
        FHE.allowThis(encryptedConstantOne);
        FHE.allowThis(encryptedConstantZero);
        isVotingOpen = true;
        electionId = 1;
        emit VotingStarted();
    }

    modifier onlyWhenVotingOpen() {
        require(isVotingOpen, "Voting is not open");
        _;
    }

    modifier onlyWhenVotingClosed() {
        require(!isVotingOpen, "Voting is open");
        _;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner can call this function");
        _;
    }

    function closeVoting() external onlyWhenVotingOpen onlyOwner {
        isVotingOpen = false;
        emit VotingClosed();
    }

    function startVoting() external onlyOwner {
        isVotingOpen = true;
        encryptedCount = FHE.asEuint32(0);
        FHE.allowThis(encryptedCount);
        clearCount = 0;
        electionId++;

        emit VotingStarted();
    }

    function eboolToOneOrZero(ebool boolValue) private returns (euint32) {
        return FHE.select(boolValue, encryptedConstantOne, encryptedConstantZero);
    }

    function subtractFromCount(euint32 valueToSubtract) private {
        encryptedCount = FHE.sub(encryptedCount, valueToSubtract);
        FHE.allowThis(encryptedCount);
    }

    function addToCount(euint32 valueToAdd) private {
        encryptedCount = FHE.add(encryptedCount, valueToAdd);
        FHE.allowThis(encryptedCount);
    }

    function setVote(ebool currentVote, address voter) private {
        voterStates[voter] = VoterState(electionId, currentVote);
        FHE.allow(currentVote, voter);
        FHE.allowThis(currentVote);
    }

    // using a boolean allows us to ensure what we add is always 0 or 1
    function vote(externalEbool externalYesOrNo, bytes calldata proof) external onlyWhenVotingOpen {
        ebool currentVote = FHE.fromExternal(externalYesOrNo, proof);
        VoterState memory state = voterStates[msg.sender];

        euint32 valueToAdd;
        if (state.lastElectionId != electionId) {
            valueToAdd = eboolToOneOrZero(currentVote);
            // state update happens in setVote
        } else {
            // subtract the previous vote from the total, and then add the new one
            ebool previousVote = state.encryptedVote;
            euint32 valueToSubtract = eboolToOneOrZero(previousVote);
            subtractFromCount(valueToSubtract);

            valueToAdd = eboolToOneOrZero(currentVote);
        }
        addToCount(valueToAdd);

        setVote(currentVote, msg.sender);
    }

    function getCount() external view onlyWhenVotingClosed returns (euint32) {
        return encryptedCount;
    }

    function getMyVote() external view returns (ebool) {
        VoterState memory state = voterStates[msg.sender];
        require(state.lastElectionId == electionId, "You have not voted yet");
        return state.encryptedVote;
    }

    function requestDecryption() external onlyWhenVotingClosed onlyOwner {
        bytes32[] memory cypherTexts = new bytes32[](1);
        cypherTexts[0] = FHE.toBytes32(encryptedCount);
        FHE.requestDecryption(
            // the list of encrypted values we want to publc decrypt
            cypherTexts,
            // the function selector the FHEVM backend will callback with the clear values as arguments
            this.callbackDecryptSingleUint32.selector
        );
    }

    function getDecryptedCount() external view onlyWhenVotingClosed returns (uint32) {
        return clearCount;
    }

    function callbackDecryptSingleUint32(
        uint256 requestID,
        bytes memory cleartexts,
        bytes memory decryptionProof
    ) external {
        // The `cleartexts` argument is an ABI encoding of the decrypted values associated to the
        // handles (using `abi.encode`).
        // ===============================
        //      SECURITY WARNING!        //
        // ===============================
        // Must call `FHE.checkSignatures(...)` here!
        //            ------------------------
        // This callback must only be called by the authorized FHEVM backend.
        // To enforce this, the contract author MUST verify the authenticity of the caller
        // by using the `FHE.checkSignatures` helper. This ensures that the provided signatures
        // match the expected FHEVM backend and prevents unauthorized or malicious calls.
        //
        // Failing to perform this verification allows anyone to invoke this function with
        // forged values, potentially compromising contract integrity.
        //
        // The responsibility for signature validation lies entirely with the contract author.
        //
        // The signatures are included in the `decryptionProof` parameter.
        //
        FHE.checkSignatures(requestID, cleartexts, decryptionProof);

        uint32 decryptedInput = abi.decode(cleartexts, (uint32));
        clearCount = decryptedInput;

        emit CountDecrypted(clearCount);
    }
}
\end{lstlisting}

\subsection{FHERankedVoter.sol}

\begin{lstlisting}[language=Solidity, caption=FHERankedVoter.sol]
// SPDX-License-Identifier: BSD-3-Clause-Clear
pragma solidity ^0.8.24;

import {FHE, euint32, externalEuint32, ebool, externalEbool} from "@fhevm/solidity/lib/FHE.sol";
import {SepoliaConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

// IDEA: to allow for a voting scheme that has multiple candidates (and only one vote per candidate) we can receive
// an array of booleans (and a proof that only one of them is true? or can we handle this internally with some FHE operations?)
// such as `select`
// https://claude.ai/share/d065d579-5b33-4c03-a9e7-98586997c237
// this has some ideas to implement ZK proofs for the multiple votes
// we may need to use zk proofs in order to verify that the user provided exactly one true value in the array of booleans
// what we can do with FHE is get an ebool that (when decrypted) is true <=> the sum of all user votes is exactly k
// where k is the number of candidates someone can vote (think ranked voting systems...)
// however, we would need to decrypt that number! And that is not very secure... it would give us info about exactly how many votes
// someone made.
// ZK proofs are better. They would allow us to verify that the user provided <= k true values in the array of booleans.
// without us knowing the exact number of true values in their array

// inherits from SepoliaConfig to enable fhEVM support
contract FHEVoter is SepoliaConfig {
    struct VoterState {
        uint256 lastElectionId;
        ebool encryptedVote;
    }

    euint32 private encryptedCount;
    euint32 private encryptedConstantOne;
    euint32 private encryptedConstantZero;
    mapping(address => VoterState) private voterStates;

    uint32 private clearCount; // =0 by default. It is only used when the owner calls "decryptCount"
    address private owner;
    bool private isVotingOpen;
    uint256 private electionId;

    event CountDecrypted(uint32 count);
    event VotingStarted();
    event VotingClosed();

    constructor() {
        owner = msg.sender;
        encryptedConstantOne = FHE.asEuint32(1);
        encryptedConstantZero = FHE.asEuint32(0);
        FHE.allowThis(encryptedConstantOne);
        FHE.allowThis(encryptedConstantZero);
        isVotingOpen = true;
        electionId = 1;
        emit VotingStarted();
    }

    modifier onlyWhenVotingOpen() {
        require(isVotingOpen, "Voting is not open");
        _;
    }

    modifier onlyWhenVotingClosed() {
        require(!isVotingOpen, "Voting is open");
        _;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner can call this function");
        _;
    }

    function closeVoting() external onlyWhenVotingOpen onlyOwner {
        isVotingOpen = false;
        emit VotingClosed();
    }

    function startVoting() external onlyOwner {
        isVotingOpen = true;
        encryptedCount = FHE.asEuint32(0);
        FHE.allowThis(encryptedCount);
        clearCount = 0;
        electionId++;

        emit VotingStarted();
    }

    function eboolToOneOrZero(ebool boolValue) private returns (euint32) {
        return FHE.select(boolValue, encryptedConstantOne, encryptedConstantZero);
    }

    function subtractFromCount(euint32 valueToSubtract) private {
        encryptedCount = FHE.sub(encryptedCount, valueToSubtract);
        FHE.allowThis(encryptedCount);
    }

    function addToCount(euint32 valueToAdd) private {
        encryptedCount = FHE.add(encryptedCount, valueToAdd);
        FHE.allowThis(encryptedCount);
    }

    function setVote(ebool currentVote, address voter) private {
        voterStates[voter] = VoterState(electionId, currentVote);
        FHE.allow(currentVote, voter);
        FHE.allowThis(currentVote);
    }

    // using a boolean allows us to ensure what we add is always 0 or 1
    function vote(externalEbool externalYesOrNo, bytes calldata proof) external onlyWhenVotingOpen {
        ebool currentVote = FHE.fromExternal(externalYesOrNo, proof);
        VoterState memory state = voterStates[msg.sender];

        euint32 valueToAdd;
        if (state.lastElectionId != electionId) {
            valueToAdd = eboolToOneOrZero(currentVote);
            // state update happens in setVote
        } else {
            // subtract the previous vote from the total, and then add the new one
            ebool previousVote = state.encryptedVote;
            euint32 valueToSubtract = eboolToOneOrZero(previousVote);
            subtractFromCount(valueToSubtract);

            valueToAdd = eboolToOneOrZero(currentVote);
        }
        addToCount(valueToAdd);

        setVote(currentVote, msg.sender);
    }

    function getCount() external view onlyWhenVotingClosed returns (euint32) {
        return encryptedCount;
    }

    function getMyVote() external view returns (ebool) {
        VoterState memory state = voterStates[msg.sender];
        require(state.lastElectionId == electionId, "You have not voted yet");
        return state.encryptedVote;
    }

    function requestDecryption() external onlyWhenVotingClosed onlyOwner {
        bytes32[] memory cypherTexts = new bytes32[](1);
        cypherTexts[0] = FHE.toBytes32(encryptedCount);
        FHE.requestDecryption(
            // the list of encrypted values we want to publicly decrypt
            cypherTexts,
            // the function selector the FHEVM backend will callback with the clear values as arguments
            this.callbackDecryptSingleUint32.selector
        );
    }

    function getDecryptedCount() external view onlyWhenVotingClosed returns (uint32) {
        return clearCount;
    }

    function callbackDecryptSingleUint32(
        uint256 requestID,
        bytes memory cleartexts,
        bytes memory decryptionProof
    ) external {
        // The `cleartexts` argument is an ABI encoding of the decrypted values associated to the
        // handles (using `abi.encode`).
        // ===============================
        //      SECURITY WARNING!        //
        // ===============================
        // Must call `FHE.checkSignatures(...)` here!
        //            ------------------------
        // This callback must only be called by the authorized FHEVM backend.
        // To enforce this, the contract author MUST verify the authenticity of the caller
        // by using the `FHE.checkSignatures` helper. This ensures that the provided signatures
        // match the expected FHEVM backend and prevents unauthorized or malicious calls.
        //
        // Failing to perform this verification allows anyone to invoke this function with
        // forged values, potentially compromising contract integrity.
        //
        // The responsibility for signature validation lies entirely with the contract author.
        //
        // The signatures are included in the `decryptionProof` parameter.
        //
        FHE.checkSignatures(requestID, cleartexts, decryptionProof);

        uint32 decryptedInput = abi.decode(cleartexts, (uint32));
        clearCount = decryptedInput;

        emit CountDecrypted(clearCount);
    }
}
\end{lstlisting}

\end{document}